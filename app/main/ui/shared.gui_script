local ____lualib = require("lualib_bundle")
local __TS__ArrayFilter = ____lualib.__TS__ArrayFilter
local Error = ____lualib.Error
local RangeError = ____lualib.RangeError
local ReferenceError = ____lualib.ReferenceError
local SyntaxError = ____lualib.SyntaxError
local TypeError = ____lualib.TypeError
local URIError = ____lualib.URIError
local __TS__New = ____lualib.__TS__New
local ____exports = {}
local set_events, setup, setup_coins, setup_life, setup_store, setup_right_container, on_sound, on_music, setup_busters, setup_hammer, setup_spinning, setup_horizontal_rocket, setup_vertical_rocket, setup_life_notification, setup_not_enough_coins, on_life_tick, set_infinit_life, on_infinit_life_tick, set_enabled_coins, set_enabled_lifes, set_enabled_store_button, set_enabled_sound_button, set_enabled_music_button, on_add_coins, on_remove_coins, on_add_lifes, on_remove_lifes, on_scene_loaded, on_gameover, set_enabled_store, set_enabled_life_notification, set_enabled_not_enough_coins, set_enabled_hammer, set_enabled_spinning, set_enabled_horizontall_rocket, set_enabled_vertical_rocket, set_text
local druid = require("druid.druid")
local ____utils = require("game.utils")
local add_lifes = ____utils.add_lifes
local add_coins = ____utils.add_coins
local is_enough_coins = ____utils.is_enough_coins
local remove_coins = ____utils.remove_coins
local remove_lifes = ____utils.remove_lifes
local get_current_level = ____utils.get_current_level
local remove_ad = ____utils.remove_ad
local ____utils = require("utils.utils")
local parse_time = ____utils.parse_time
local ____game_config = require("main.game_config")
local Dlg = ____game_config.Dlg
function set_events(data)
    EventBus.on("ON_SCENE_LOADED", on_scene_loaded, true)
    EventBus.on("ON_GAME_OVER", on_gameover, true)
    EventBus.on(
        "SET_LIFE_NOTIFICATION",
        function() return set_enabled_life_notification(true) end,
        true
    )
    EventBus.on("ADDED_LIFE", on_add_lifes, true)
    EventBus.on("REMOVED_LIFE", on_remove_lifes, true)
    EventBus.on("ADDED_COIN", on_add_coins, true)
    EventBus.on("REMOVED_COIN", on_remove_coins, true)
    EventBus.on(
        "NOT_ENOUGH_LIFE",
        function() return set_enabled_life_notification(true) end,
        true
    )
    EventBus.on(
        "REQUEST_OPEN_STORE",
        function() return set_enabled_store(data, true) end
    )
    EventBus.on(
        "TRY_BUY_HAMMER",
        function()
            if data.dlg_opened then
                return
            end
            set_enabled_hammer(data, true)
        end,
        true
    )
    EventBus.on(
        "TRY_BUY_SPINNING",
        function()
            if data.dlg_opened then
                return
            end
            set_enabled_spinning(data, true)
        end,
        true
    )
    EventBus.on(
        "TRY_BUY_HORIZONTAL_ROCKET",
        function()
            if data.dlg_opened then
                return
            end
            set_enabled_horizontall_rocket(data, true)
        end,
        true
    )
    EventBus.on(
        "TRY_BUY_VERTICAL_ROCKET",
        function()
            if data.dlg_opened then
                return
            end
            set_enabled_vertical_rocket(data, true)
        end,
        true
    )
    EventBus.on(
        "PURCHASE_INITIALIZED",
        function()
            if #GAME_CONFIG.products >= 3 then
                local maney150 = __TS__ArrayFilter(
                    GAME_CONFIG.products,
                    function(____, p) return p.id == "maney150" end
                )[1]
                local maney300 = __TS__ArrayFilter(
                    GAME_CONFIG.products,
                    function(____, p) return p.id == "maney300" end
                )[1]
                local maney800 = __TS__ArrayFilter(
                    GAME_CONFIG.products,
                    function(____, p) return p.id == "maney800" end
                )[1]
                set_text("store/buy_150_text", (maney150.priceValue .. " ") .. maney150.priceCurrencyCode)
                set_text("store/buy_300_text", (maney300.priceValue .. " ") .. maney300.priceCurrencyCode)
                set_text("store/buy_800_text", (maney800.priceValue .. " ") .. maney800.priceCurrencyCode)
            end
        end
    )
    EventBus.on("SOUND_BUTTON", on_sound, false)
    EventBus.on("MUSIC_BUTTON", on_music, false)
end
function setup(data)
    setup_coins(data)
    setup_life(data)
    setup_store(data)
    setup_right_container(data)
    setup_life_notification(data)
    setup_not_enough_coins(data)
    setup_busters(data)
end
function setup_coins(data)
    data.druid:new_button(
        "coins/box",
        function() return set_enabled_store(data, true) end
    )
    gui.set_text(
        gui.get_node("coins/text"),
        tostring(GameStorage.get("coins"))
    )
end
function setup_life(data)
    data.druid:new_button(
        "lifes/box",
        function() return set_enabled_store(data, true) end
    )
    gui.set_text(
        gui.get_node("lifes/text"),
        tostring(GameStorage.get("life").amount)
    )
end
function setup_store(data)
    data.druid:new_button(
        "store/close",
        function() return set_enabled_store(data, false) end
    )
    gui.set_text(
        gui.get_node("store/store_title_text"),
        Lang.get_text("store_title")
    )
    data.druid:new_button(
        "store/buy_150_btn",
        function()
            if HtmlBridge == nil then
                Sound.play("purchase")
                add_coins(150)
                return
            end
            HtmlBridge.purchase(
                {id = "maney150"},
                function(result, purchase)
                    if not result then
                        return function()
                        end
                    end
                    Sound.play("purchase")
                    add_coins(150)
                    GameStorage.set("was_purchased", true)
                    Metrica.report("data", {shop = {buy = "maney150"}})
                    HtmlBridge.consume_purchase(
                        purchase.purchaseToken,
                        function()
                        end
                    )
                end
            )
        end
    )
    data.druid:new_button(
        "store/buy_300_btn",
        function()
            if HtmlBridge == nil then
                Sound.play("purchase")
                add_coins(300)
                return
            end
            HtmlBridge.purchase(
                {id = "maney300"},
                function(result, purchase)
                    if not result then
                        return function()
                        end
                    end
                    Sound.play("purchase")
                    add_coins(300)
                    GameStorage.set("was_purchased", true)
                    Metrica.report("data", {shop = {buy = "maney300"}})
                    HtmlBridge.consume_purchase(
                        purchase.purchaseToken,
                        function()
                        end
                    )
                end
            )
        end
    )
    data.druid:new_button(
        "store/buy_800_btn",
        function()
            if HtmlBridge == nil then
                Sound.play("purchase")
                add_coins(800)
                return
            end
            HtmlBridge.purchase(
                {id = "maney800"},
                function(result, purchase)
                    if not result then
                        return function()
                        end
                    end
                    Sound.play("purchase")
                    add_coins(800)
                    GameStorage.set("was_purchased", true)
                    Metrica.report("data", {shop = {buy = "maney800"}})
                    HtmlBridge.consume_purchase(
                        purchase.purchaseToken,
                        function()
                        end
                    )
                end
            )
        end
    )
    gui.set_text(
        gui.get_node("store/life_title_text"),
        Lang.get_text("lifes")
    )
    data.druid:new_button(
        "store/buy_x1_btn",
        function()
            if not is_enough_coins(20) then
                return set_enabled_not_enough_coins(data, true)
            end
            Sound.play("purchase")
            add_lifes(1)
            remove_coins(20)
            Metrica.report("data", {shop = {buy = "life1"}})
        end
    )
    data.druid:new_button(
        "store/buy_x2_btn",
        function()
            if not is_enough_coins(35) then
                return set_enabled_not_enough_coins(data, true)
            end
            Sound.play("purchase")
            add_lifes(2)
            remove_coins(35)
            Metrica.report("data", {shop = {buy = "life2"}})
        end
    )
    data.druid:new_button(
        "store/buy_x3_btn",
        function()
            if not is_enough_coins(50) then
                return set_enabled_not_enough_coins(data, true)
            end
            Sound.play("purchase")
            add_lifes(3)
            remove_coins(50)
            Metrica.report("data", {shop = {buy = "life3"}})
        end
    )
    gui.set_text(
        gui.get_node("store/junior_box/text"),
        Lang.get_text("junior_box")
    )
    data.druid:new_button(
        "store/junior_box/buy_button/button",
        function()
            if not is_enough_coins(60) then
                return set_enabled_not_enough_coins(data, true)
            end
            Sound.play("purchase")
            remove_coins(60)
            set_infinit_life(1)
            GameStorage.set(
                "hammer_counts",
                GameStorage.get("hammer_counts") + 1
            )
            GameStorage.set(
                "vertical_rocket_counts",
                GameStorage.get("vertical_rocket_counts") + 1
            )
            EventBus.send("UPDATED_BUTTONS")
            Metrica.report("data", {shop = {buy = "set1"}})
            Metrica.report("data", {buy_0 = {id = "hammer"}})
            Metrica.report("data", {buy_0 = {id = "vertical_rocket"}})
        end
    )
    gui.set_text(
        gui.get_node("store/catlover_box/text"),
        Lang.get_text("catlover_box")
    )
    data.druid:new_button(
        "store/catlover_box/buy_button/button",
        function()
            if not is_enough_coins(100) then
                return set_enabled_not_enough_coins(data, true)
            end
            Sound.play("purchase")
            remove_coins(100)
            set_infinit_life(24)
            GameStorage.set(
                "hammer_counts",
                GameStorage.get("hammer_counts") + 2
            )
            GameStorage.set(
                "spinning_counts",
                GameStorage.get("spinning_counts") + 1
            )
            GameStorage.set(
                "vertical_rocket_counts",
                GameStorage.get("vertical_rocket_counts") + 2
            )
            EventBus.send("UPDATED_BUTTONS")
            Metrica.report("data", {shop = {buy = "set2"}})
            Metrica.report("data", {buy_0 = {level = 0, id = "hammer"}})
            Metrica.report("data", {buy_0 = {level = 0, id = "hammer"}})
            Metrica.report("data", {buy_0 = {level = 0, id = "spinning"}})
            Metrica.report("data", {buy_0 = {level = 0, id = "vertical_rocket"}})
            Metrica.report("data", {buy_0 = {level = 0, id = "vertical_rocket"}})
        end
    )
    gui.set_text(
        gui.get_node("store/ad_title_text"),
        Lang.get_text("remove_ad")
    )
    data.druid:new_button(
        "store/buy_ad_1_btn",
        function()
            if HtmlBridge == nil then
                Sound.play("purchase")
                remove_ad(24 * 60 * 60)
                return
            end
            HtmlBridge.purchase(
                {id = "noads1"},
                function(result, purchase)
                    if not result then
                        return function()
                        end
                    end
                    Sound.play("purchase")
                    remove_ad(24 * 60 * 60)
                    Metrica.report("data", {shop = {buy = "noads1"}})
                    HtmlBridge.consume_purchase(
                        purchase.purchaseToken,
                        function()
                        end
                    )
                end
            )
        end
    )
    data.druid:new_button(
        "store/buy_ad_7_btn",
        function()
            if HtmlBridge == nil then
                Sound.play("purchase")
                remove_ad(24 * 60 * 60 * 7)
                return
            end
            HtmlBridge.purchase(
                {id = "noads7"},
                function(result, purchase)
                    if not result then
                        return function()
                        end
                    end
                    Sound.play("purchase")
                    remove_ad(24 * 60 * 60 * 7)
                    Metrica.report("data", {shop = {buy = "noads7"}})
                    HtmlBridge.consume_purchase(
                        purchase.purchaseToken,
                        function()
                        end
                    )
                end
            )
        end
    )
    data.druid:new_button(
        "store/buy_ad_30_btn",
        function()
            if HtmlBridge == nil then
                Sound.play("purchase")
                remove_ad(24 * 60 * 60 * 30)
                return
            end
            HtmlBridge.purchase(
                {id = "noads30"},
                function(result, purchase)
                    if not result then
                        return function()
                        end
                    end
                    Sound.play("purchase")
                    remove_ad(24 * 60 * 60 * 30)
                    Metrica.report("data", {shop = {buy = "noads30"}})
                    HtmlBridge.consume_purchase(
                        purchase.purchaseToken,
                        function()
                        end
                    )
                end
            )
        end
    )
    if GAME_CONFIG.debug_levels then
        gui.set_enabled(
            gui.get_node("store/reset/button"),
            true
        )
        data.druid:new_button(
            "store/reset/button",
            function()
                remove_coins(GameStorage.get("coins"))
                remove_lifes(GameStorage.get("life").amount)
                local life = GameStorage.get("life")
                life.start_time = System.now() - life.start_time
                GameStorage.set("life", life)
                on_life_tick()
                local infinit_life = GameStorage.get("infinit_life")
                infinit_life.start_time = System.now() - infinit_life.duration
                GameStorage.set("infinit_life", infinit_life)
                on_infinit_life_tick()
                GameStorage.set("hammer_counts", 0)
                GameStorage.set("spinning_counts", 0)
                GameStorage.set("horizontal_rocket_counts", 0)
                GameStorage.set("vertical_rocket_counts", 0)
            end
        )
    end
end
function setup_right_container(data)
    data.druid:new_button(
        "store_button",
        function() return set_enabled_store(data, true) end
    )
    data.druid:new_button("sound", on_sound)
    data.druid:new_button("music", on_music)
    local sound_off = gui.get_node("sound_off")
    local music_off = gui.get_node("music_off")
    gui.set_enabled(
        sound_off,
        not Sound.is_sfx_active()
    )
    gui.set_enabled(
        music_off,
        not Sound.is_music_active()
    )
end
function on_sound()
    local sound_off = gui.get_node("sound_off")
    local state = not Sound.is_sfx_active()
    Sound.set_sfx_active(state)
    gui.set_enabled(sound_off, not state)
end
function on_music()
    local music_off = gui.get_node("music_off")
    local state = not Sound.is_music_active()
    Sound.set_music_active(state)
    gui.set_enabled(music_off, not state)
end
function setup_busters(data)
    setup_hammer(data)
    setup_spinning(data)
    setup_horizontal_rocket(data)
    setup_vertical_rocket(data)
end
function setup_hammer(data)
    gui.set_text(
        gui.get_node("hammer/title_text"),
        Lang.get_text("hammer")
    )
    gui.set_text(
        gui.get_node("hammer/description"),
        Lang.get_text("hammer_description")
    )
    gui.set_text(
        gui.get_node("hammer/buy_button_text"),
        Lang.get_text("buy") .. " 30"
    )
    data.druid:new_button(
        "hammer/buy_button",
        function()
            if not is_enough_coins(30) then
                set_enabled_hammer(data, false)
                set_enabled_not_enough_coins(data, true)
                return
            end
            remove_coins(30)
            GameStorage.set("hammer_counts", 1)
            EventBus.send("UPDATED_BUTTONS")
            set_enabled_hammer(data, false)
            Metrica.report(
                "data",
                {["buy_" .. tostring(get_current_level() + 1)] = {id = "hammer"}}
            )
        end
    )
    data.druid:new_button(
        "hammer/close",
        function()
            set_enabled_hammer(data, false)
        end
    )
end
function setup_spinning(data)
    gui.set_text(
        gui.get_node("spinning/title_text"),
        Lang.get_text("spinning")
    )
    gui.set_text(
        gui.get_node("spinning/description"),
        Lang.get_text("spinning_description")
    )
    gui.set_text(
        gui.get_node("spinning/buy_button_text"),
        Lang.get_text("buy") .. " 30"
    )
    data.druid:new_button(
        "spinning/buy_button",
        function()
            if not is_enough_coins(30) then
                set_enabled_spinning(data, false)
                set_enabled_not_enough_coins(data, true)
                return
            end
            remove_coins(30)
            GameStorage.set("spinning_counts", 1)
            EventBus.send("UPDATED_BUTTONS")
            set_enabled_spinning(data, false)
            Metrica.report(
                "data",
                {["buy_" .. tostring(get_current_level() + 1)] = {id = "spinning"}}
            )
        end
    )
    data.druid:new_button(
        "spinning/close",
        function()
            set_enabled_spinning(data, false)
        end
    )
end
function setup_horizontal_rocket(data)
    gui.set_text(
        gui.get_node("horizontal_rocket/title_text"),
        Lang.get_text("rocket")
    )
    gui.set_text(
        gui.get_node("horizontal_rocket/description"),
        Lang.get_text("horizontal_rocket_description")
    )
    gui.set_text(
        gui.get_node("horizontal_rocket/buy_button_text"),
        Lang.get_text("buy") .. " 30"
    )
    data.druid:new_button(
        "horizontal_rocket/buy_button",
        function()
            if not is_enough_coins(30) then
                set_enabled_horizontall_rocket(data, false)
                set_enabled_not_enough_coins(data, true)
                return
            end
            remove_coins(30)
            GameStorage.set("horizontal_rocket_counts", 1)
            EventBus.send("UPDATED_BUTTONS")
            set_enabled_horizontall_rocket(data, false)
            Metrica.report(
                "data",
                {["buy_" .. tostring(get_current_level() + 1)] = {id = "horizontal_rocket"}}
            )
        end
    )
    data.druid:new_button(
        "horizontal_rocket/close",
        function()
            set_enabled_horizontall_rocket(data, false)
        end
    )
end
function setup_vertical_rocket(data)
    gui.set_text(
        gui.get_node("vertical_rocket/title_text"),
        Lang.get_text("rocket")
    )
    gui.set_text(
        gui.get_node("vertical_rocket/description"),
        Lang.get_text("vertical_rocket_description")
    )
    gui.set_text(
        gui.get_node("vertical_rocket/buy_button_text"),
        Lang.get_text("buy") .. " 30"
    )
    data.druid:new_button(
        "vertical_rocket/buy_button",
        function()
            if not is_enough_coins(30) then
                set_enabled_vertical_rocket(data, false)
                set_enabled_not_enough_coins(data, true)
                return
            end
            remove_coins(30)
            GameStorage.set("vertical_rocket_counts", 1)
            EventBus.send("UPDATED_BUTTONS")
            set_enabled_vertical_rocket(data, false)
            Metrica.report(
                "data",
                {["buy_" .. tostring(get_current_level() + 1)] = {id = "vertical_rocket"}}
            )
        end
    )
    data.druid:new_button(
        "vertical_rocket/close",
        function()
            set_enabled_vertical_rocket(data, false)
        end
    )
end
function setup_life_notification(data)
    data.druid:new_button(
        "life_notification/buy_button",
        function()
            if not is_enough_coins(30) then
                set_enabled_life_notification(false)
                set_enabled_not_enough_coins(data, true)
                return
            end
            set_enabled_life_notification(false)
            remove_coins(30)
            add_lifes(1)
        end
    )
    data.druid:new_button(
        "life_notification/close",
        function() return set_enabled_life_notification(false) end
    )
end
function setup_not_enough_coins(data)
    data.druid:new_button(
        "not_enough_coins/buy_button",
        function()
            local store = gui.get_node("store/manager")
            if gui.is_enabled(store, false) then
                set_enabled_not_enough_coins(data, false)
                return
            end
            set_enabled_not_enough_coins(data, false)
            set_enabled_store(data, true)
        end
    )
end
function on_life_tick()
    local life = GameStorage.get("life")
    local delta = System.now() - life.start_time
    gui.set_text(
        gui.get_node("life_notification/time_text"),
        parse_time(20 * 60 - delta)
    )
    if delta < 20 * 60 then
        return
    end
    add_lifes(1)
    life.start_time = System.now()
    GameStorage.set("life", life)
end
function set_infinit_life(duration)
    local life = GameStorage.get("infinit_life")
    life.is_active = true
    life.duration = duration * 60 * 60
    life.start_time = System.now()
    GameStorage.set("infinit_life", life)
end
function on_infinit_life_tick()
    local life = GameStorage.get("infinit_life")
    if not life.is_active then
        return
    end
    local delta = System.now() - life.start_time
    gui.play_flipbook(
        gui.get_node("lifes/icon"),
        "infinite_life_icon"
    )
    local text = gui.get_node("lifes/text")
    gui.set_text(
        text,
        parse_time(life.duration - delta)
    )
    if delta >= life.duration then
        life.is_active = false
        GameStorage.set("infinit_life", life)
        gui.play_flipbook(
            gui.get_node("lifes/icon"),
            "life_icon"
        )
        gui.set_text(
            text,
            tostring(GameStorage.get("life").amount)
        )
    end
end
function set_enabled_coins(state)
    local coins = gui.get_node("coins/box")
    gui.set_enabled(coins, state)
end
function set_enabled_lifes(state)
    local coins = gui.get_node("lifes/box")
    gui.set_enabled(coins, state)
end
function set_enabled_store_button(state)
    local store_button = gui.get_node("store_button")
    gui.set_enabled(store_button, state)
end
function set_enabled_sound_button(state)
    local sound_button = gui.get_node("sound")
    gui.set_enabled(sound_button, state)
end
function set_enabled_music_button(state)
    local music_button = gui.get_node("music")
    gui.set_enabled(music_button, state)
end
function on_add_coins()
    local coins_text = gui.get_node("coins/text")
    gui.set_text(
        coins_text,
        tostring(GameStorage.get("coins"))
    )
end
function on_remove_coins()
    local coins_text = gui.get_node("coins/text")
    gui.set_text(
        coins_text,
        tostring(GameStorage.get("coins"))
    )
end
function on_add_lifes()
    if GameStorage.get("infinit_life").is_active then
        return
    end
    local lifes_text = gui.get_node("lifes/text")
    gui.set_text(
        lifes_text,
        tostring(GameStorage.get("life").amount)
    )
end
function on_remove_lifes()
    if GameStorage.get("infinit_life").is_active then
        return
    end
    local lifes_text = gui.get_node("lifes/text")
    gui.set_text(
        lifes_text,
        tostring(GameStorage.get("life").amount)
    )
end
function on_scene_loaded(scene)
    repeat
        local ____switch126 = scene.name
        local ____cond126 = ____switch126 == "movie" or ____switch126 == "game"
        if ____cond126 then
            set_enabled_coins(false)
            set_enabled_lifes(false)
            set_enabled_store_button(false)
            set_enabled_sound_button(false)
            set_enabled_music_button(false)
            break
        end
        ____cond126 = ____cond126 or ____switch126 == "map"
        if ____cond126 then
            set_enabled_coins(true)
            set_enabled_lifes(true)
            set_enabled_store_button(true)
            set_enabled_sound_button(true)
            set_enabled_music_button(true)
            break
        end
    until true
end
function on_gameover()
    timer.delay(
        GAME_CONFIG.delay_before_gameover,
        false,
        function()
            set_enabled_coins(true)
            set_enabled_lifes(true)
        end
    )
end
function set_enabled_store(data, state)
    local store = gui.get_node("store/manager")
    if state and gui.is_enabled(store, false) then
        return
    end
    repeat
        local ____switch131 = Scene.get_current_name()
        local ____cond131 = ____switch131 == "game"
        if ____cond131 then
            set_enabled_hammer(data, false)
            set_enabled_spinning(data, false)
            set_enabled_horizontall_rocket(data, false)
            set_enabled_vertical_rocket(data, false)
            set_enabled_coins(state)
            set_enabled_lifes(state)
            break
        end
        ____cond131 = ____cond131 or ____switch131 == "map"
        if ____cond131 then
            set_enabled_store_button(not state)
            set_enabled_sound_button(not state)
            set_enabled_music_button(not state)
            break
        end
    until true
    if state then
        gui.set_enabled(store, state)
        gui.animate(
            gui.get_node("store/dlg"),
            "position",
            vmath.vector3(270, 480, 0),
            gui.EASING_INCUBIC,
            0.3
        )
        gui.animate(
            gui.get_node("fade"),
            "color",
            vmath.vector4(0, 0, 0, GAME_CONFIG.fade_value),
            gui.EASING_INCUBIC,
            0.3
        )
        EventBus.send("OPENED_DLG", Dlg.Store)
        Sound.play("store")
    else
        gui.animate(
            gui.get_node("fade"),
            "color",
            vmath.vector4(0, 0, 0, 0),
            gui.EASING_INCUBIC,
            0.3
        )
        gui.animate(
            gui.get_node("store/dlg"),
            "position",
            vmath.vector3(270, 1500, 0),
            gui.EASING_INCUBIC,
            0.3,
            0,
            function()
                gui.set_enabled(store, state)
            end
        )
        EventBus.send("CLOSED_DLG", Dlg.Store)
        Sound.stop("store")
    end
    data.is_store_open = state
end
function set_enabled_life_notification(state)
    local life = gui.get_node("life_notification/manager")
    if state then
        gui.set_enabled(life, state)
        gui.animate(
            gui.get_node("life_notification/dlg"),
            "position",
            vmath.vector3(270, 480, 0),
            gui.EASING_INCUBIC,
            0.3
        )
        gui.animate(
            gui.get_node("fade"),
            "color",
            vmath.vector4(0, 0, 0, GAME_CONFIG.fade_value),
            gui.EASING_INCUBIC,
            0.3
        )
        EventBus.send("OPENED_DLG", Dlg.LifeNotification)
    else
        gui.animate(
            gui.get_node("fade"),
            "color",
            vmath.vector4(0, 0, 0, 0),
            gui.EASING_INCUBIC,
            0.3
        )
        gui.animate(
            gui.get_node("life_notification/dlg"),
            "position",
            vmath.vector3(270, 1150, 0),
            gui.EASING_INCUBIC,
            0.3,
            0,
            function()
                gui.set_enabled(life, state)
            end
        )
        EventBus.send("CLOSED_DLG", Dlg.LifeNotification)
    end
    EventBus.send("LIFE_NOTIFICATION", state)
end
function set_enabled_not_enough_coins(data, state)
    local coins = gui.get_node("not_enough_coins/manager")
    if state then
        gui.set_enabled(coins, state)
        gui.animate(
            gui.get_node("not_enough_coins/dlg"),
            "position",
            vmath.vector3(270, 480, 0),
            gui.EASING_INCUBIC,
            0.3
        )
        if not data.is_store_open then
            gui.animate(
                gui.get_node("fade"),
                "color",
                vmath.vector4(0, 0, 0, GAME_CONFIG.fade_value),
                gui.EASING_INCUBIC,
                0.3
            )
        end
        EventBus.send("OPENED_DLG", Dlg.NotEnoughCoins)
    else
        if not data.is_store_open then
            gui.animate(
                gui.get_node("fade"),
                "color",
                vmath.vector4(0, 0, 0, 0),
                gui.EASING_INCUBIC,
                0.3
            )
        end
        gui.animate(
            gui.get_node("not_enough_coins/dlg"),
            "position",
            vmath.vector3(270, 1150, 0),
            gui.EASING_INCUBIC,
            0.3,
            0,
            function()
                gui.set_enabled(coins, state)
            end
        )
        EventBus.send("CLOSED_DLG", Dlg.NotEnoughCoins)
    end
end
function set_enabled_hammer(data, state)
    local hammer = gui.get_node("hammer/manager")
    set_enabled_coins(state)
    set_enabled_lifes(state)
    if state then
        gui.set_enabled(hammer, state)
        gui.animate(
            gui.get_node("hammer/dlg"),
            "position",
            vmath.vector3(270, 480, 0),
            gui.EASING_INCUBIC,
            0.3
        )
        gui.animate(
            gui.get_node("fade"),
            "color",
            vmath.vector4(0, 0, 0, GAME_CONFIG.fade_value),
            gui.EASING_INCUBIC,
            0.3
        )
        EventBus.send("OPENED_DLG", Dlg.Hammer)
    else
        gui.animate(
            gui.get_node("fade"),
            "color",
            vmath.vector4(0, 0, 0, 0),
            gui.EASING_INCUBIC,
            0.3
        )
        gui.animate(
            gui.get_node("hammer/dlg"),
            "position",
            vmath.vector3(270, 1150, 0),
            gui.EASING_INCUBIC,
            0.3,
            0,
            function()
                gui.set_enabled(hammer, state)
            end
        )
        EventBus.send("CLOSED_DLG", Dlg.Hammer)
    end
    data.dlg_opened = state
end
function set_enabled_spinning(data, state)
    local spinning = gui.get_node("spinning/manager")
    set_enabled_coins(state)
    set_enabled_lifes(state)
    if state then
        gui.set_enabled(spinning, state)
        gui.animate(
            gui.get_node("spinning/dlg"),
            "position",
            vmath.vector3(270, 480, 0),
            gui.EASING_INCUBIC,
            0.3
        )
        gui.animate(
            gui.get_node("fade"),
            "color",
            vmath.vector4(0, 0, 0, GAME_CONFIG.fade_value),
            gui.EASING_INCUBIC,
            0.3
        )
        EventBus.send("OPENED_DLG", Dlg.Spinning)
    else
        gui.animate(
            gui.get_node("fade"),
            "color",
            vmath.vector4(0, 0, 0, 0),
            gui.EASING_INCUBIC,
            0.3
        )
        gui.animate(
            gui.get_node("spinning/dlg"),
            "position",
            vmath.vector3(270, 1150, 0),
            gui.EASING_INCUBIC,
            0.3,
            0,
            function()
                gui.set_enabled(spinning, state)
            end
        )
        EventBus.send("CLOSED_DLG", Dlg.Spinning)
    end
    data.dlg_opened = state
end
function set_enabled_horizontall_rocket(data, state)
    local horizontal_rocket = gui.get_node("horizontal_rocket/manager")
    set_enabled_coins(state)
    set_enabled_lifes(state)
    if state then
        gui.set_enabled(horizontal_rocket, state)
        gui.animate(
            gui.get_node("horizontal_rocket/dlg"),
            "position",
            vmath.vector3(270, 480, 0),
            gui.EASING_INCUBIC,
            0.3
        )
        gui.animate(
            gui.get_node("fade"),
            "color",
            vmath.vector4(0, 0, 0, GAME_CONFIG.fade_value),
            gui.EASING_INCUBIC,
            0.3
        )
        EventBus.send("OPENED_DLG", Dlg.HorizontalRocket)
    else
        gui.animate(
            gui.get_node("fade"),
            "color",
            vmath.vector4(0, 0, 0, 0),
            gui.EASING_INCUBIC,
            0.3
        )
        gui.animate(
            gui.get_node("horizontal_rocket/dlg"),
            "position",
            vmath.vector3(270, 1150, 0),
            gui.EASING_INCUBIC,
            0.3,
            0,
            function()
                gui.set_enabled(horizontal_rocket, state)
            end
        )
        EventBus.send("CLOSED_DLG", Dlg.HorizontalRocket)
    end
    data.dlg_opened = state
end
function set_enabled_vertical_rocket(data, state)
    local vertical_rocket = gui.get_node("vertical_rocket/manager")
    set_enabled_coins(state)
    set_enabled_lifes(state)
    if state then
        gui.set_enabled(vertical_rocket, state)
        gui.animate(
            gui.get_node("vertical_rocket/dlg"),
            "position",
            vmath.vector3(270, 480, 0),
            gui.EASING_INCUBIC,
            0.3
        )
        gui.animate(
            gui.get_node("fade"),
            "color",
            vmath.vector4(0, 0, 0, GAME_CONFIG.fade_value),
            gui.EASING_INCUBIC,
            0.3
        )
        EventBus.send("OPENED_DLG", Dlg.VerticalRocket)
    else
        gui.animate(
            gui.get_node("fade"),
            "color",
            vmath.vector4(0, 0, 0, 0),
            gui.EASING_INCUBIC,
            0.3
        )
        gui.animate(
            gui.get_node("vertical_rocket/dlg"),
            "position",
            vmath.vector3(270, 1150, 0),
            gui.EASING_INCUBIC,
            0.3,
            0,
            function()
                gui.set_enabled(vertical_rocket, state)
            end
        )
        EventBus.send("CLOSED_DLG", Dlg.VerticalRocket)
    end
    data.dlg_opened = state
end
function set_text(arg0, arg1)
    error(
        __TS__New(Error, "Function not implemented."),
        0
    )
end
function ____exports.init(self)
    Manager.init_script()
    self.druid = druid.new(self)
    gui.set_render_order(10)
    setup(self)
    set_events(self)
    on_life_tick()
    timer.delay(1, true, on_life_tick)
    on_infinit_life_tick()
    timer.delay(1, true, on_infinit_life_tick)
    if Scene.get_current_name() == "movie" then
        set_enabled_coins(false)
        set_enabled_lifes(false)
        set_enabled_store_button(false)
        set_enabled_sound_button(false)
        set_enabled_music_button(false)
    end
end
function ____exports.on_input(self, action_id, action)
    local ____opt_0 = self.druid
    GAME_CONFIG.is_busy_input = ____opt_0 and ____opt_0:on_input(action_id, action)
end
function ____exports.update(self, dt)
    local ____opt_2 = self.druid
    if ____opt_2 ~= nil then
        ____opt_2:update(dt)
    end
end
function ____exports.on_message(self, message_id, message, sender)
    Manager.on_message(self, message_id, message, sender)
    local ____opt_4 = self.druid
    if ____opt_4 ~= nil then
        ____opt_4:on_message(message_id, message, sender)
    end
end
function ____exports.final(self)
    self.druid:final()
    Manager.final_script()
end
init = ____exports.init
on_input = ____exports.on_input
update = ____exports.update
on_message = ____exports.on_message
final = ____exports.final

