local ____lualib = require("lualib_bundle")
local __TS__ArrayIncludes = ____lualib.__TS__ArrayIncludes
local __TS__ArrayIsArray = ____lualib.__TS__ArrayIsArray
local ____exports = {}
local setup, setup_info_ui, setup_avatar_or_clock, setup_step_or_time, setup_targets, setup_busters, set_enabled_settings, setup_sustem_ui, setup_win_ui, next_level, setup_gameover_ui, to_map, set_animal_tutorial_tip, set_events, off_buster_tip_popup, update_targets, set_target, feed_animation, update_buttons, set_tutorial, click_in_two_pos, hand_click_animation, hand_swap_animation, remove_tutorial, on_win_end, drop_steptime, drop_targets, fade_steptime, fade_targets, drop_coins, set_gameover, set_gameover_offer, disabled_gameover_offer, disable_game_ui, on_shuffle_start, on_shuffle_action, presets, hand_timer
local flow = require("ludobits.m.flow")
local druid = require("druid.druid")
local ____game_config = require("main.game_config")
local Dlg = ____game_config.Dlg
local ____utils = require("utils.utils")
local format_string = ____utils.format_string
local get_point_curve = ____utils.get_point_curve
local parse_time = ____utils.parse_time
local set_text = ____utils.set_text
local set_text_colors = ____utils.set_text_colors
local ____utils = require("game.utils")
local get_current_level = ____utils.get_current_level
local get_current_level_config = ____utils.get_current_level_config
local is_animal_level = ____utils.is_animal_level
local is_enough_coins = ____utils.is_enough_coins
local is_last_level = ____utils.is_last_level
local is_time_level = ____utils.is_time_level
local remove_coins = ____utils.remove_coins
local remove_lifes = ____utils.remove_lifes
local ____game = require("game.game")
local TargetType = ____game.TargetType
function setup(instance)
    setup_info_ui(instance)
    setup_busters(instance)
    if GAME_CONFIG.debug_levels then
        setup_sustem_ui(instance)
    end
    setup_win_ui(instance)
    setup_gameover_ui(instance)
end
function setup_info_ui(instance)
    setup_step_or_time(instance)
    setup_avatar_or_clock(instance)
    setup_targets(instance)
    set_text(
        "current_level",
        (Lang.get_text("level") .. " ") .. tostring(GameStorage.get("current_level") + 1)
    )
    if System.platform == "HTML5" and html5.run("new URL(location).searchParams.get('hide')||'0'") == "1" then
        set_text("current_level", "")
    end
    gui.animate(
        gui.get_node("substrate"),
        "position",
        vmath.vector3(270, 880, 0),
        gui.EASING_INCUBIC,
        0.5
    )
end
function setup_avatar_or_clock(instance)
    if __TS__ArrayIncludes(
        GAME_CONFIG.animal_levels,
        GameStorage.get("current_level") + 1
    ) then
        local avatar = gui.get_node("avatar")
        local clock = gui.get_node("clock")
        gui.set_enabled(avatar, false)
        gui.set_enabled(clock, true)
    end
end
function setup_step_or_time(instance)
    if instance.level.time ~= nil then
        local node = gui.get_node("timer")
        gui.set_enabled(node, true)
        set_text(
            "time",
            parse_time(instance.level.time)
        )
        gui.set_text(
            gui.get_node("step_time_box/text"),
            Lang.get_text("time")
        )
    end
    if instance.level.steps ~= nil then
        local node = gui.get_node("step_counter")
        gui.set_enabled(node, true)
        set_text("steps", instance.level.steps)
        gui.set_text(
            gui.get_node("step_time_box/text"),
            Lang.get_text("steps")
        )
        if System.platform == "HTML5" and html5.run("new URL(location).searchParams.get('hide')||'0'") == "1" then
            set_text("step_time_box/text", "")
        end
    end
end
function setup_targets(instance)
    local targets = instance.level.targets
    do
        local i = 0
        while i < #targets do
            local target = targets[i + 1]
            if target ~= nil then
                local node = gui.get_node(presets.targets[i + 1].node_name)
                gui.set_enabled(node, true)
                gui.set_position(node, presets.targets[i + 1].preset_depend_of_length[#targets].position)
                gui.set_scale(node, presets.targets[i + 1].preset_depend_of_length[#targets].scale)
                local view
                if target.type == TargetType.Cell then
                    view = GAME_CONFIG.cell_view[target.id]
                    if __TS__ArrayIsArray(view) then
                        view = view[#view]
                    end
                else
                    view = GAME_CONFIG.element_view[target.id]
                end
                gui.play_flipbook(
                    gui.get_node(presets.targets[i + 1].node_name .. "_icon"),
                    view == "cell_web" and view .. "_ui" or view
                )
                set_text(presets.targets[i + 1].node_name .. "_counts", target.count)
            end
            i = i + 1
        end
    end
    gui.set_text(
        gui.get_node("targets_box/text"),
        Lang.get_text("targets")
    )
    if System.platform == "HTML5" and html5.run("new URL(location).searchParams.get('hide')||'0'") == "1" then
        set_text("targets_box/text", "")
    end
end
function setup_busters(instance)
    if __TS__ArrayIncludes(
        GAME_CONFIG.animal_levels,
        GameStorage.get("current_level") + 1
    ) then
        return
    end
    local busters = gui.get_node("buster_buttons")
    gui.set_enabled(busters, true)
    local pos = gui.get_position(busters)
    pos.y = pos.y + GAME_CONFIG.bottom_offset
    if GAME_CONFIG.debug_levels then
        pos.y = pos.y + 125
    end
    gui.set_position(busters, pos)
    instance.druid:new_button(
        "spinning/button",
        function()
            if GameStorage.get("spinning_opened") then
                if GameStorage.get("spinning_counts") == 0 then
                    if __TS__ArrayIncludes(
                        GAME_CONFIG.tutorial_levels,
                        GameStorage.get("current_level") + 1
                    ) then
                        if __TS__ArrayIncludes(
                            GameStorage.get("completed_tutorials"),
                            GameStorage.get("current_level") + 1
                        ) then
                            EventBus.send("TRY_BUY_SPINNING")
                        end
                    else
                        EventBus.send("TRY_BUY_SPINNING")
                    end
                    return
                end
                EventBus.send("ACTIVATE_BUSTER", {name = "SPINNING"})
            else
                local popup = gui.get_node("popup")
                gui.set_position(
                    popup,
                    vmath.vector3(-70, -5, 0)
                )
                set_text(
                    "popup/text",
                    format_string(
                        Lang.get_text("buster_open"),
                        {9}
                    )
                )
                gui.set_enabled(
                    popup,
                    not gui.is_enabled(popup, false)
                )
            end
        end
    )
    if GameStorage.get("spinning_opened") then
        gui.set_enabled(
            gui.get_node("spinning/lock"),
            false
        )
        gui.set_enabled(
            gui.get_node("spinning/icon"),
            true
        )
        gui.set_enabled(
            gui.get_node("spinning/counts"),
            true
        )
    end
    instance.druid:new_button(
        "hammer/button",
        function()
            if GameStorage.get("hammer_opened") then
                if GameStorage.get("hammer_counts") == 0 then
                    if __TS__ArrayIncludes(
                        GAME_CONFIG.tutorial_levels,
                        GameStorage.get("current_level") + 1
                    ) then
                        if __TS__ArrayIncludes(
                            GameStorage.get("completed_tutorials"),
                            GameStorage.get("current_level") + 1
                        ) then
                            EventBus.send("TRY_BUY_HAMMER")
                        end
                    else
                        EventBus.send("TRY_BUY_HAMMER")
                    end
                    return
                end
                EventBus.send("ACTIVATE_BUSTER", {name = "HAMMER"})
            else
                local popup = gui.get_node("popup")
                gui.set_position(
                    popup,
                    vmath.vector3(-170, -5, 0)
                )
                set_text(
                    "popup/text",
                    format_string(
                        Lang.get_text("buster_open"),
                        {6}
                    )
                )
                gui.set_enabled(
                    popup,
                    not gui.is_enabled(popup, false)
                )
            end
        end
    )
    if GameStorage.get("hammer_opened") then
        gui.set_enabled(
            gui.get_node("hammer/lock"),
            false
        )
        gui.set_enabled(
            gui.get_node("hammer/icon"),
            true
        )
        gui.set_enabled(
            gui.get_node("hammer/counts"),
            true
        )
    end
    instance.druid:new_button(
        "horizontal_rocket/button",
        function()
            if GameStorage.get("horizontal_rocket_opened") then
                if GameStorage.get("horizontal_rocket_counts") == 0 then
                    if __TS__ArrayIncludes(
                        GAME_CONFIG.tutorial_levels,
                        GameStorage.get("current_level") + 1
                    ) then
                        if __TS__ArrayIncludes(
                            GameStorage.get("completed_tutorials"),
                            GameStorage.get("current_level") + 1
                        ) then
                            EventBus.send("TRY_BUY_HORIZONTAL_ROCKET")
                        end
                    else
                        EventBus.send("TRY_BUY_HORIZONTAL_ROCKET")
                    end
                    return
                end
                EventBus.send("ACTIVATE_BUSTER", {name = "HORIZONTAL_ROCKET"})
            else
                local popup = gui.get_node("popup")
                gui.set_position(
                    popup,
                    vmath.vector3(30, -5, 0)
                )
                set_text(
                    "popup/text",
                    format_string(
                        Lang.get_text("buster_open"),
                        {17}
                    )
                )
                gui.set_enabled(
                    popup,
                    not gui.is_enabled(popup, false)
                )
            end
        end
    )
    if GameStorage.get("horizontal_rocket_opened") then
        gui.set_enabled(
            gui.get_node("horizontal_rocket/lock"),
            false
        )
        gui.set_enabled(
            gui.get_node("horizontal_rocket/icon"),
            true
        )
        gui.set_enabled(
            gui.get_node("horizontal_rocket/counts"),
            true
        )
    end
    instance.druid:new_button(
        "vertical_rocket/button",
        function()
            if GameStorage.get("vertical_rocket_opened") then
                if GameStorage.get("vertical_rocket_counts") == 0 then
                    if __TS__ArrayIncludes(
                        GAME_CONFIG.tutorial_levels,
                        GameStorage.get("current_level") + 1
                    ) then
                        if __TS__ArrayIncludes(
                            GameStorage.get("completed_tutorials"),
                            GameStorage.get("current_level") + 1
                        ) then
                            EventBus.send("TRY_BUY_VERTICAL_ROCKET")
                        end
                    else
                        EventBus.send("TRY_BUY_VERTICAL_ROCKET")
                    end
                    return
                end
                EventBus.send("ACTIVATE_BUSTER", {name = "VERTICAL_ROCKET"})
            else
                local popup = gui.get_node("popup")
                gui.set_position(
                    popup,
                    vmath.vector3(130, -5, 0)
                )
                set_text(
                    "popup/text",
                    format_string(
                        Lang.get_text("buster_open"),
                        {17}
                    )
                )
                gui.set_enabled(
                    popup,
                    not gui.is_enabled(popup, false)
                )
            end
        end
    )
    if GameStorage.get("vertical_rocket_opened") then
        gui.set_enabled(
            gui.get_node("vertical_rocket/lock"),
            false
        )
        gui.set_enabled(
            gui.get_node("vertical_rocket/icon"),
            true
        )
        gui.set_enabled(
            gui.get_node("vertical_rocket/counts"),
            true
        )
    end
    instance.druid:new_button(
        "settings/button",
        function()
            if __TS__ArrayIncludes(
                GAME_CONFIG.tutorial_levels,
                GameStorage.get("current_level") + 1
            ) then
                if not __TS__ArrayIncludes(
                    GameStorage.get("completed_tutorials"),
                    GameStorage.get("current_level") + 1
                ) then
                    return
                end
            end
            instance.settings_opened = not instance.settings_opened
            set_enabled_settings(instance.settings_opened)
            instance.druid:new_button(
                "sound",
                function()
                    EventBus.send("SOUND_BUTTON")
                    local sound_off = gui.get_node("sound_off")
                    gui.set_enabled(
                        sound_off,
                        not Sound.is_sfx_active()
                    )
                end
            )
            instance.druid:new_button(
                "music",
                function()
                    EventBus.send("MUSIC_BUTTON")
                    local music_off = gui.get_node("music_off")
                    gui.set_enabled(
                        music_off,
                        not Sound.is_music_active()
                    )
                end
            )
            instance.druid:new_button(
                "store",
                function()
                    set_enabled_settings(false)
                    instance.settings_opened = false
                    Sound.stop("game")
                    EventBus.send("REQUEST_OPEN_STORE")
                end
            )
            instance.druid:new_button(
                "map",
                function()
                    Sound.stop("game")
                    Scene.load("map")
                end
            )
            local sound_off = gui.get_node("sound_off")
            local music_off = gui.get_node("music_off")
            gui.set_enabled(
                sound_off,
                not Sound.is_sfx_active()
            )
            gui.set_enabled(
                music_off,
                not Sound.is_music_active()
            )
        end
    )
    update_buttons(instance)
end
function set_enabled_settings(state)
    local sound = gui.get_node("sound")
    local music = gui.get_node("music")
    local store = gui.get_node("store")
    local map = gui.get_node("map")
    if state then
        local sound_pos = gui.get_position(sound)
        sound_pos.y = sound_pos.y + 80
        gui.set_enabled(sound, true)
        gui.animate(
            sound,
            gui.PROP_POSITION,
            sound_pos,
            gui.EASING_INCUBIC,
            0.3
        )
        local music_pos = gui.get_position(music)
        music_pos.y = music_pos.y + 150
        gui.set_enabled(music, true)
        gui.animate(
            music,
            gui.PROP_POSITION,
            music_pos,
            gui.EASING_INCUBIC,
            0.3
        )
        local store_pos = gui.get_position(store)
        store_pos.y = store_pos.y + 220
        gui.set_enabled(store, true)
        gui.animate(
            store,
            gui.PROP_POSITION,
            store_pos,
            gui.EASING_INCUBIC,
            0.3
        )
        local map_pos = gui.get_position(map)
        map_pos.y = map_pos.y + 290
        gui.set_enabled(map, true)
        gui.animate(
            map,
            gui.PROP_POSITION,
            map_pos,
            gui.EASING_INCUBIC,
            0.3
        )
    else
        local sound_pos = gui.get_position(sound)
        sound_pos.y = sound_pos.y - 80
        gui.animate(
            sound,
            gui.PROP_POSITION,
            sound_pos,
            gui.EASING_INCUBIC,
            0.3,
            0,
            function()
                gui.set_enabled(sound, false)
            end
        )
        local music_pos = gui.get_position(music)
        music_pos.y = music_pos.y - 150
        gui.animate(
            music,
            gui.PROP_POSITION,
            music_pos,
            gui.EASING_INCUBIC,
            0.3,
            0,
            function()
                gui.set_enabled(music, false)
            end
        )
        local store_pos = gui.get_position(store)
        store_pos.y = store_pos.y - 220
        gui.animate(
            store,
            gui.PROP_POSITION,
            store_pos,
            gui.EASING_INCUBIC,
            0.3,
            0,
            function()
                gui.set_enabled(store, false)
            end
        )
        local map_pos = gui.get_position(map)
        map_pos.y = map_pos.y - 290
        gui.animate(
            map,
            gui.PROP_POSITION,
            map_pos,
            gui.EASING_INCUBIC,
            0.3,
            0,
            function()
                gui.set_enabled(map, false)
            end
        )
    end
    off_buster_tip_popup()
end
function setup_sustem_ui(instance)
    instance.druid:new_button(
        "back/button",
        function()
            Sound.stop("game")
            Scene.load("map")
        end
    )
    instance.druid:new_button(
        "restart/button",
        function()
            GAME_CONFIG.is_restart = true
            Scene.restart()
        end
    )
    instance.druid:new_button(
        "rewind/button",
        function() return EventBus.send("REQUEST_REWIND") end
    )
    gui.animate(
        gui.get_node("system_buttons"),
        "position",
        vmath.vector3(0, -40, 0),
        gui.EASING_INCUBIC,
        0.5
    )
end
function setup_win_ui(instance)
    instance.druid:new_button(
        "continue_button",
        function()
            gui.set_enabled(
                gui.get_node("continue_button"),
                false
            )
            if not GameStorage.get("was_purchased") then
                Ads.show_interstitial(true, next_level)
            else
                next_level()
            end
        end
    )
    instance.druid:new_button("win_close", to_map)
    instance.druid:new_button("last_level_btn", to_map)
    gui.set_enabled(
        gui.get_node("win"),
        false
    )
    gui.set_text(
        gui.get_node("win_text"),
        Lang.get_text("win_title")
    )
    gui.set_text(
        gui.get_node("continue_text"),
        Lang.get_text("next")
    )
    gui.set_text(
        gui.get_node("last_level_btn_text"),
        Lang.get_text("on_map")
    )
    gui.set_text(
        gui.get_node("last_level_text"),
        Lang.get_text("last_level_text")
    )
end
function next_level()
    GAME_CONFIG.steps_by_ad = 0
    GameStorage.set(
        "current_level",
        GameStorage.get("current_level") + 1
    )
    GAME_CONFIG.is_restart = true
    Scene.restart()
end
function setup_gameover_ui(instance)
    gui.set_text(
        gui.get_node("gameover_text"),
        Lang.get_text("gameover_title")
    )
    gui.set_text(
        gui.get_node("restart_text"),
        Lang.get_text("restart")
    )
    instance.druid:new_button(
        "restart_button",
        function()
            if not GameStorage.get("infinit_life").is_active and GameStorage.get("life").amount == 0 then
                EventBus.send("SET_LIFE_NOTIFICATION")
                return
            end
            GAME_CONFIG.steps_by_ad = 0
            GAME_CONFIG.is_restart = true
            Scene.restart()
        end
    )
    gui.set_text(
        gui.get_node("map_text"),
        Lang.get_text("map")
    )
    instance.druid:new_button("map_button", to_map)
    instance.druid:new_button("gameover_close", to_map)
    instance.druid:new_button("gameover_offer_close", disabled_gameover_offer)
    gui.set_text(
        gui.get_node("steps_by_ad/text"),
        "+3 " .. Lang.get_text("3steps")
    )
    instance.druid:new_button(
        "steps_by_ad/button",
        function()
            Ads.show_reward(function()
                GAME_CONFIG.steps_by_ad = GAME_CONFIG.steps_by_ad + 1
                Metrica.report(
                    "data",
                    {["fail_level_" .. tostring(get_current_level() + 1)] = {event = "3step_ads"}}
                )
                EventBus.send("REVIVE", {steps = 3})
            end)
        end
    )
    gui.set_text(
        gui.get_node("steps_by_coins/text"),
        "+5 " .. Lang.get_text("5steps")
    )
    gui.set_text(
        gui.get_node("steps_by_coins/text1"),
        "30"
    )
    instance.druid:new_button(
        "steps_by_coins/button",
        function()
            if not is_enough_coins(30) then
                EventBus.send("REQUEST_OPEN_STORE")
                return
            end
            remove_coins(30)
            Metrica.report(
                "data",
                {["fail_level_" .. tostring(get_current_level() + 1)] = {event = "5step_money"}}
            )
            EventBus.send("REVIVE", {steps = 5})
        end
    )
    gui.set_text(
        gui.get_node("time_by_coins/text"),
        "+20 " .. Lang.get_text("sec")
    )
    gui.set_text(
        gui.get_node("time_by_coins/text1"),
        "40"
    )
    instance.druid:new_button(
        "time_by_coins/button",
        function()
            if not is_enough_coins(40) then
                EventBus.send("REQUEST_OPEN_STORE")
                return
            end
            remove_coins(40)
            Metrica.report(
                "data",
                {["fail_level_" .. tostring(get_current_level() + 1)] = {event = "time_money"}}
            )
            EventBus.send("REVIVE", {time = 20})
        end
    )
end
function to_map()
    if not GameStorage.get("was_purchased") then
        Ads.show_interstitial(
            true,
            function()
                Sound.stop("game")
                Scene.load("map")
            end
        )
    else
        Sound.stop("game")
        Scene.load("map")
    end
end
function set_animal_tutorial_tip()
    local window = gui.get_node("window")
    gui.set_enabled(window, true)
    gui.set_text(
        gui.get_node("description"),
        Lang.get_text("animal_tutorial_description")
    )
    gui.set_text(
        gui.get_node("description1"),
        Lang.get_text("animal_tutorial_description1")
    )
end
function set_events(instance)
    EventBus.on("SET_ANIMAL_TUTORIAL_TIP", set_animal_tutorial_tip, true)
    EventBus.on(
        "INIT_UI",
        function() return setup(instance) end
    )
    EventBus.on(
        "UPDATED_STEP_COUNTER",
        function(steps) return set_text("steps", steps) end,
        true
    )
    EventBus.on(
        "UPDATED_TARGET_UI",
        function(data) return update_targets(data) end,
        true
    )
    EventBus.on(
        "UPDATED_BUTTONS",
        function() return update_buttons(instance) end,
        true
    )
    EventBus.on(
        "GAME_TIMER",
        function(time) return set_text(
            "time",
            parse_time(time)
        ) end,
        true
    )
    EventBus.on("SET_TUTORIAL", set_tutorial, true)
    EventBus.on("REMOVE_TUTORIAL", remove_tutorial, true)
    EventBus.on("ON_WIN_END", on_win_end)
    EventBus.on(
        "ON_GAME_OVER",
        function(state)
            timer.delay(
                GAME_CONFIG.delay_before_gameover,
                false,
                function()
                    set_gameover(instance, state)
                end
            )
        end,
        true
    )
    EventBus.on("SHUFFLE_START", on_shuffle_start)
    EventBus.on("SHUFFLE_ACTION", on_shuffle_action)
    EventBus.on(
        "OPENED_DLG",
        function(dlg)
            if dlg == Dlg.Store then
                instance.block_input = true
            end
        end
    )
    EventBus.on(
        "CLOSED_DLG",
        function(dlg)
            if dlg == Dlg.Store then
                instance.block_input = false
                Sound.play("game")
            end
        end
    )
    EventBus.on("INPUT", off_buster_tip_popup, false)
end
function off_buster_tip_popup()
    local popup = gui.get_node("popup")
    if gui.is_enabled(popup, false) then
        gui.set_enabled(popup, false)
    end
end
function update_targets(data)
    if data.pos ~= nil and data.type == TargetType.Element then
        local pos = Camera.world_to_screen(data.pos)
        local element = gui.new_box_node(
            pos,
            vmath.vector3(40, 40, 1)
        )
        local view = GAME_CONFIG.element_view[data.id]
        gui.set_texture(element, "graphics")
        gui.play_flipbook(element, view)
        gui.animate(
            element,
            gui.PROP_POSITION,
            vmath.vector3(450, 850, 0),
            gui.EASING_INQUAD,
            0.5,
            0,
            function()
                gui.delete_node(element)
                set_target(data)
            end
        )
    else
        set_target(data)
    end
end
function set_target(data)
    repeat
        local ____switch117 = data.idx
        local ____cond117 = ____switch117 == 0
        if ____cond117 then
            set_text(
                "first_target_counts",
                math.max(0, data.amount)
            )
            break
        end
        ____cond117 = ____cond117 or ____switch117 == 1
        if ____cond117 then
            set_text(
                "second_target_counts",
                math.max(0, data.amount)
            )
            break
        end
        ____cond117 = ____cond117 or ____switch117 == 2
        if ____cond117 then
            set_text(
                "third_target_counts",
                math.max(0, data.amount)
            )
            break
        end
    until true
end
function feed_animation()
    local level_config = get_current_level_config()
    local item_id = 0
    for ____, target in ipairs(level_config.targets) do
        if target.type == TargetType.Element and __TS__ArrayIncludes(GAME_CONFIG.feed_elements, target.id) then
            item_id = target.id
        end
    end
    do
        local i = 0
        while i < 5 do
            timer.delay(
                0.05 * i,
                false,
                function()
                    flow.start(function()
                        local element = gui.new_box_node(
                            vmath.vector3(420, 870, 0),
                            vmath.vector3(40, 40, 1)
                        )
                        local view = GAME_CONFIG.element_view[item_id]
                        gui.set_texture(element, "graphics")
                        gui.play_flipbook(element, view)
                        local ltrb = Camera.get_ltrb()
                        local width = 540
                        local height = math.abs(ltrb.w)
                        local points = {{x = 420, y = 870}, {x = width * 0.3, y = height * 0.5}, {x = width * 0.5, y = 20 + GAME_CONFIG.bottom_offset}}
                        if GAME_CONFIG.debug_levels then
                            points[#points].y = width * 0.4 + GAME_CONFIG.bottom_offset
                        end
                        local result = vmath.vector3()
                        do
                            local i = 0
                            while i < 100 do
                                local p = get_point_curve(i / 100, points, result)
                                gui.animate(
                                    element,
                                    gui.PROP_POSITION,
                                    p,
                                    gui.EASING_LINEAR,
                                    0.01
                                )
                                flow.delay(0.01)
                                i = i + 1
                            end
                        end
                        local scale = gui.get_scale(element)
                        scale.x = scale.x * 2
                        scale.y = scale.y * 2
                        gui.animate(
                            element,
                            gui.PROP_SCALE,
                            scale,
                            gui.EASING_INCUBIC,
                            0.5,
                            0,
                            function()
                                timer.delay(
                                    2,
                                    false,
                                    function()
                                        gui.delete_node(element)
                                    end
                                )
                            end
                        )
                    end)
                end
            )
            i = i + 1
        end
    end
end
function update_buttons(instance)
    local spinning = GameStorage.get("spinning_counts")
    set_text("spinning/counts", spinning == 0 and "+" or spinning)
    set_text_colors({"spinning/button"}, "#fff", instance.busters.spinning.active and 0.5 or 1)
    if GameStorage.get("spinning_opened") then
        gui.set_enabled(
            gui.get_node("spinning/lock"),
            false
        )
        gui.set_enabled(
            gui.get_node("spinning/icon"),
            true
        )
        gui.set_enabled(
            gui.get_node("spinning/counts"),
            true
        )
    end
    local hammer = GameStorage.get("hammer_counts")
    set_text("hammer/counts", hammer == 0 and "+" or hammer)
    set_text_colors({"hammer/button"}, "#fff", instance.busters.hammer.active and 0.5 or 1)
    if GameStorage.get("hammer_opened") then
        gui.set_enabled(
            gui.get_node("hammer/lock"),
            false
        )
        gui.set_enabled(
            gui.get_node("hammer/icon"),
            true
        )
        gui.set_enabled(
            gui.get_node("hammer/counts"),
            true
        )
    end
    local horizontal_rocket = GameStorage.get("horizontal_rocket_counts")
    set_text("horizontal_rocket/counts", horizontal_rocket == 0 and "+" or horizontal_rocket)
    set_text_colors({"horizontal_rocket/button"}, "#fff", instance.busters.horizontal_rocket.active and 0.5 or 1)
    if GameStorage.get("horizontal_rocket_opened") then
        gui.set_enabled(
            gui.get_node("horizontal_rocket/lock"),
            false
        )
        gui.set_enabled(
            gui.get_node("horizontal_rocket/icon"),
            true
        )
        gui.set_enabled(
            gui.get_node("horizontal_rocket/counts"),
            true
        )
    end
    local vertical_rocket = GameStorage.get("vertical_rocket_counts")
    set_text("vertical_rocket/counts", vertical_rocket == 0 and "+" or vertical_rocket)
    set_text_colors({"vertical_rocket/button"}, "#fff", instance.busters.vertical_rocket.active and 0.5 or 1)
    if GameStorage.get("vertical_rocket_opened") then
        gui.set_enabled(
            gui.get_node("vertical_rocket/lock"),
            false
        )
        gui.set_enabled(
            gui.get_node("vertical_rocket/icon"),
            true
        )
        gui.set_enabled(
            gui.get_node("vertical_rocket/counts"),
            true
        )
    end
end
function set_tutorial()
    local tutorial_data = GAME_CONFIG.tutorials_data[GameStorage.get("current_level") + 1]
    local tutorial = gui.get_node("tutorial")
    local tutorial_text = gui.get_node("tutorial_text")
    gui.set_position(tutorial_text, tutorial_data.text.pos)
    gui.set_text(
        tutorial_text,
        Lang.get_text(tutorial_data.text.data)
    )
    gui.set_enabled(tutorial, true)
    gui.set_enabled(
        gui.get_node("lock1"),
        true
    )
    if tutorial_data.arrow_pos ~= nil then
        local arrow = gui.get_node("arrow")
        gui.set_enabled(arrow, true)
        gui.set_position(arrow, tutorial_data.arrow_pos)
    end
    if tutorial_data.buster_icon ~= nil then
        local buster = gui.get_node("buster")
        local buster_icon = gui.get_node("buster_icon")
        gui.set_enabled(buster, true)
        gui.set_position(buster, tutorial_data.buster_icon.pos)
        gui.play_flipbook(buster_icon, tutorial_data.buster_icon.icon)
    end
    if tutorial_data.busters ~= nil then
        local busters = __TS__ArrayIsArray(tutorial_data.busters) and tutorial_data.busters or ({tutorial_data.busters})
        for ____, buster in ipairs(busters) do
            gui.set_layer(
                gui.get_node(buster .. "/button"),
                "top"
            )
        end
    end
    repeat
        local ____switch140 = get_current_level() + 1
        local ____cond140 = ____switch140 == 6
        if ____cond140 then
            hand_timer = timer.delay(
                2,
                false,
                function()
                    local from_pos = vmath.vector3(-200, -400, 0)
                    local to_pos = vmath.vector3(100, 70, 0)
                    if GAME_CONFIG.debug_levels then
                        from_pos.y = from_pos.y + 125
                        to_pos.y = to_pos.y + 50
                    end
                    click_in_two_pos(from_pos, to_pos)
                end
            )
            break
        end
        ____cond140 = ____cond140 or ____switch140 == 7
        if ____cond140 then
            hand_timer = timer.delay(
                2,
                false,
                function()
                    local pos = vmath.vector3(-245, -210, 0)
                    if GAME_CONFIG.debug_levels then
                        pos.y = pos.y + 50
                    end
                    hand_click_animation(pos)
                end
            )
            break
        end
        ____cond140 = ____cond140 or ____switch140 == 8
        if ____cond140 then
            hand_timer = timer.delay(2, false, hand_swap_animation)
            break
        end
        ____cond140 = ____cond140 or ____switch140 == 9
        if ____cond140 then
            hand_timer = timer.delay(
                2,
                false,
                function()
                    local pos = vmath.vector3(-100, -400, 0)
                    if GAME_CONFIG.debug_levels then
                        pos.y = pos.y + 125
                    end
                    hand_click_animation(pos)
                end
            )
            break
        end
        ____cond140 = ____cond140 or ____switch140 == 17
        if ____cond140 then
            hand_timer = timer.delay(
                2,
                false,
                function()
                    local from_pos = vmath.vector3(0, -400, 0)
                    local to_pos = vmath.vector3(-100, 10, 0)
                    if GAME_CONFIG.debug_levels then
                        from_pos.y = from_pos.y + 125
                        to_pos.y = to_pos.y + 50
                    end
                    click_in_two_pos(from_pos, to_pos)
                end
            )
            break
        end
    until true
end
function click_in_two_pos(pos1, pos2)
    local hand = gui.get_node("hand")
    hand_click_animation(
        pos1,
        function()
            timer.delay(
                1,
                false,
                function()
                    hand_click_animation(
                        pos2,
                        function()
                            gui.set_enabled(hand, false)
                            timer.delay(
                                1,
                                false,
                                function()
                                    click_in_two_pos(pos1, pos2)
                                end
                            )
                        end
                    )
                end
            )
        end
    )
end
function hand_click_animation(position, on_end)
    local hand = gui.get_node("hand")
    gui.set_position(hand, position)
    gui.set_enabled(hand, true)
    gui.animate(
        hand,
        gui.PROP_SCALE,
        vmath.vector3(0.5, 0.5, 0.5),
        gui.EASING_INCUBIC,
        1,
        0,
        function()
            gui.set_enabled(hand, false)
            if on_end ~= nil then
                on_end()
            else
                timer.delay(
                    1,
                    false,
                    function()
                        hand_click_animation(position, on_end)
                    end
                )
            end
        end,
        gui.PLAYBACK_ONCE_PINGPONG
    )
end
function hand_swap_animation()
    local hand = gui.get_node("hand")
    local color = gui.get_color(hand)
    local from_pos = vmath.vector3(70, 50, 0)
    local to_pos = vmath.vector3(190, 50, 0)
    if GAME_CONFIG.debug_levels then
        from_pos.y = from_pos.y + 50
        to_pos.y = to_pos.y + 50
    end
    gui.set_position(hand, from_pos)
    color.w = 0.5
    gui.set_color(hand, color)
    gui.set_enabled(hand, true)
    color.w = 1
    gui.animate(
        hand,
        gui.PROP_COLOR,
        color,
        gui.EASING_INCUBIC,
        0.3,
        0,
        function()
            gui.animate(
                hand,
                gui.PROP_POSITION,
                to_pos,
                gui.EASING_INCUBIC,
                1,
                0,
                function()
                    color.w = 0.5
                    gui.animate(
                        hand,
                        gui.PROP_COLOR,
                        color,
                        gui.EASING_INCUBIC,
                        0.7,
                        0,
                        function()
                            gui.set_enabled(hand, false)
                            timer.delay(1, false, hand_swap_animation)
                        end
                    )
                end
            )
        end
    )
end
function remove_tutorial()
    if hand_timer ~= nil then
        timer.cancel(hand_timer)
    end
    gui.set_enabled(
        gui.get_node("lock1"),
        false
    )
    gui.set_enabled(
        gui.get_node("tutorial"),
        false
    )
end
function on_win_end(data)
    if is_animal_level() then
        timer.delay(0.1, false, feed_animation)
    end
    timer.delay(
        is_animal_level() and GAME_CONFIG.animal_level_delay_before_win or GAME_CONFIG.delay_before_win,
        false,
        function()
            disable_game_ui()
            local lock = gui.get_node("lock1")
            gui.set_enabled(lock, true)
            gui.set_alpha(lock, 0)
            gui.animate(
                lock,
                gui.PROP_COLOR,
                vmath.vector4(0, 0, 0, GAME_CONFIG.fade_value),
                gui.EASING_INCUBIC,
                0.6,
                0,
                function()
                    gui.set_enabled(
                        gui.get_node("win"),
                        true
                    )
                    if is_last_level() then
                        gui.set_enabled(
                            gui.get_node("win_close"),
                            false
                        )
                        gui.set_enabled(
                            gui.get_node("continue_button"),
                            false
                        )
                    end
                    local function on_end_for_last_level()
                        if not is_last_level() then
                            return
                        end
                        timer.delay(
                            0.5,
                            false,
                            function()
                                gui.set_enabled(
                                    gui.get_node("win"),
                                    false
                                )
                                local popup = gui.get_node("last_level_popup")
                                gui.set_enabled(popup, true)
                                gui.animate(
                                    popup,
                                    gui.PROP_POSITION,
                                    vmath.vector3(270, 480, 0),
                                    gui.EASING_INCUBIC,
                                    0.5
                                )
                            end
                        )
                    end
                    if data.with_reward then
                        local level_coins = get_current_level_config().coins
                        local steps = data.state.steps ~= nil and math.min(
                            data.state.steps,
                            get_current_level() ~= 3 and GAME_CONFIG.max_coins_reward or GAME_CONFIG.max_coins_reward_for_cock
                        ) or 0
                        local remaining_time = data.state.remaining_time ~= nil and math.min(
                            math.floor(data.state.remaining_time),
                            get_current_level() ~= 3 and GAME_CONFIG.max_coins_reward or GAME_CONFIG.max_coins_reward_for_cock
                        ) or 0
                        if level_coins > 0 then
                            local current_coins = GameStorage.get("coins")
                            local before_reward = current_coins - level_coins - steps - remaining_time
                            gui.set_enabled(
                                gui.get_node("reward"),
                                true
                            )
                            gui.set_text(
                                gui.get_node("coins_count"),
                                tostring(before_reward)
                            )
                            local function on_each_coin_drop_end(init_value, idx)
                                Sound.play("coin")
                                gui.set_text(
                                    gui.get_node("coins_count"),
                                    tostring(init_value + idx + 1)
                                )
                                local icon = gui.get_node("coin_icon")
                                local init_scale = gui.get_scale(icon)
                                gui.animate(
                                    icon,
                                    gui.PROP_SCALE,
                                    vmath.vector3(init_scale.x + 0.03, init_scale.y + 0.03, init_scale.z),
                                    gui.EASING_INELASTIC,
                                    0.01,
                                    0,
                                    function()
                                        gui.animate(
                                            icon,
                                            gui.PROP_SCALE,
                                            init_scale,
                                            gui.EASING_INELASTIC,
                                            0.01
                                        )
                                    end
                                )
                            end
                            drop_steptime(function()
                                local ltrb = Camera.get_ltrb()
                                local width = 540
                                local height = math.abs(ltrb.w)
                                local level_coin_points = {{x = 450, y = 850}, {x = width * 0.3, y = height * 0.5}, {x = 270 + 25, y = 480 - 200}}
                                if steps > 0 or remaining_time > 0 then
                                    local steptime_points = {{x = 100, y = 850}, {x = width * 0.25, y = height * 0.5}, {x = 270 + 25, y = 480 - 200}}
                                    local function on_each_coin_drop_start(idx)
                                        if steps > 0 then
                                            gui.set_text(
                                                gui.get_node("steps"),
                                                tostring(steps - (idx + 1))
                                            )
                                            return
                                        end
                                        if remaining_time > 0 then
                                            gui.set_text(
                                                gui.get_node("time"),
                                                parse_time(remaining_time - (idx + 1))
                                            )
                                            return
                                        end
                                    end
                                    drop_coins(
                                        before_reward,
                                        steps + remaining_time,
                                        steptime_points,
                                        on_each_coin_drop_start,
                                        on_each_coin_drop_end,
                                        function()
                                            fade_steptime(function()
                                                drop_targets(function()
                                                    drop_coins(
                                                        before_reward + steps + remaining_time,
                                                        level_coins,
                                                        level_coin_points,
                                                        function(idx)
                                                            gui.set_text(
                                                                gui.get_node("coins_text"),
                                                                tostring(level_coins - (idx + 1))
                                                            )
                                                        end,
                                                        on_each_coin_drop_end,
                                                        function()
                                                            fade_targets(on_end_for_last_level)
                                                        end
                                                    )
                                                end)
                                            end)
                                        end
                                    )
                                else
                                    drop_targets(function()
                                        drop_coins(
                                            before_reward,
                                            level_coins,
                                            level_coin_points,
                                            function(idx)
                                                gui.set_text(
                                                    gui.get_node("coins_text"),
                                                    tostring(level_coins - (idx + 1))
                                                )
                                            end,
                                            on_each_coin_drop_end,
                                            function()
                                                fade_targets(on_end_for_last_level)
                                            end
                                        )
                                    end)
                                end
                            end)
                        else
                            on_end_for_last_level()
                        end
                    else
                        on_end_for_last_level()
                    end
                end
            )
            Sound.play("passed")
            Sound.play("animalwin")
            local anim_props = {blend_duration = 0, playback_rate = 1}
            gui.play_spine_anim(
                gui.get_node("firework"),
                hash("firework"),
                gui.PLAYBACK_LOOP_FORWARD,
                anim_props
            )
        end
    )
end
function drop_steptime(on_end)
    gui.set_enabled(
        gui.get_node("substrate"),
        true
    )
    local steptime = gui.get_node("step_time")
    gui.set_layer(steptime, "ontop")
    local pos = gui.get_position(steptime)
    pos.y = pos.y - 300
    gui.animate(
        steptime,
        "position",
        pos,
        gui.EASING_OUTBOUNCE,
        0.5,
        0,
        on_end
    )
end
function drop_targets(on_end)
    gui.set_enabled(
        gui.get_node("substrate"),
        true
    )
    local targets = gui.get_node("targets")
    gui.set_enabled(
        gui.get_node("coins"),
        true
    )
    set_text(
        "coins_text",
        get_current_level_config().coins
    )
    gui.set_layer(targets, "ontop")
    local pos = gui.get_position(targets)
    pos.y = pos.y - 300
    gui.animate(
        targets,
        "position",
        pos,
        gui.EASING_OUTBOUNCE,
        0.5,
        0,
        on_end
    )
end
function fade_steptime(on_end)
    local steptime = gui.get_node("step_time")
    local pos = gui.get_position(steptime)
    pos.y = pos.y + 300
    gui.animate(
        steptime,
        "position",
        pos,
        gui.EASING_OUTCUBIC,
        0.5,
        0,
        function()
            gui.set_layer(steptime, "")
            gui.set_enabled(
                gui.get_node("substrate"),
                false
            )
            on_end()
        end
    )
end
function fade_targets(on_end)
    local targets = gui.get_node("targets")
    local pos = gui.get_position(targets)
    pos.y = pos.y + 300
    gui.animate(
        targets,
        "position",
        pos,
        gui.EASING_OUTCUBIC,
        0.5,
        0,
        function()
            gui.set_layer(targets, "")
            gui.set_enabled(
                gui.get_node("coins"),
                false
            )
            gui.set_enabled(
                gui.get_node("substrate"),
                false
            )
            on_end()
        end
    )
end
function drop_coins(init_value, amount, points, on_each_drop_start, on_each_drop_end, on_end)
    do
        local i = 0
        while i < amount do
            local idx = i
            timer.delay(
                0.1 * i,
                false,
                function()
                    flow.start(function()
                        local coin = gui.new_box_node(
                            vmath.vector3(points[1].x, points[1].y, 0),
                            vmath.vector3(40, 40, 1)
                        )
                        gui.set_layer(coin, "ontop")
                        gui.set_texture(coin, "ui")
                        gui.play_flipbook(coin, "coin_icon_1")
                        if on_each_drop_start ~= nil then
                            on_each_drop_start(idx)
                        end
                        local result = vmath.vector3()
                        do
                            local i = 0
                            while i < 100 do
                                local p = get_point_curve(i / 100, points, result)
                                gui.animate(
                                    coin,
                                    gui.PROP_POSITION,
                                    p,
                                    gui.EASING_LINEAR,
                                    0.01
                                )
                                flow.delay(0.01)
                                i = i + 1
                            end
                        end
                        gui.delete_node(coin)
                        if on_each_drop_end ~= nil then
                            on_each_drop_end(init_value, idx)
                        end
                    end)
                end
            )
            i = i + 1
        end
    end
    if on_end ~= nil then
        timer.delay(amount * 0.1 + 100 * 0.01, false, on_end)
    end
end
function set_gameover(instance, state)
    disable_game_ui()
    local lock = gui.get_node("lock1")
    gui.set_enabled(lock, true)
    gui.animate(
        lock,
        gui.PROP_COLOR,
        vmath.vector4(0, 0, 0, GAME_CONFIG.fade_value),
        gui.EASING_INCUBIC,
        0.3,
        0,
        function()
            gui.set_enabled(
                gui.get_node("gameover"),
                true
            )
            gui.set_enabled(
                gui.get_node("missing_targets"),
                true
            )
        end
    )
    Sound.play("failed")
    Sound.play("animallose")
    set_text(
        "missing_text",
        Lang.get_text("targets")
    )
    local target_1 = gui.get_node("target_1")
    local target_2 = gui.get_node("target_2")
    local target_3 = gui.get_node("target_3")
    if #state.targets == 1 then
        local target1 = state.targets[1]
        local view1 = ""
        if target1.type == TargetType.Cell then
            if __TS__ArrayIsArray(GAME_CONFIG.cell_view[target1.id]) then
                view1 = GAME_CONFIG.cell_view[target1.id][1]
            else
                view1 = GAME_CONFIG.cell_view[target1.id]
            end
        else
            view1 = GAME_CONFIG.element_view[target1.id]
        end
        gui.play_flipbook(
            gui.get_node("target_1"),
            view1 == "cell_web" and view1 .. "_ui" or view1
        )
        gui.set_text(
            gui.get_node("target_1_text"),
            tostring((tostring(math.min(#target1.uids, target1.count)) .. "/") .. tostring(target1.count))
        )
        gui.set_enabled(
            gui.get_node("target_1_fail_icon"),
            #target1.uids < target1.count
        )
        gui.set_position(
            target_1,
            vmath.vector3(0, 0, 0)
        )
        gui.set_enabled(target_1, true)
    elseif #state.targets == 2 then
        local target1 = state.targets[1]
        local view1 = ""
        if target1.type == TargetType.Cell then
            if __TS__ArrayIsArray(GAME_CONFIG.cell_view[target1.id]) then
                view1 = GAME_CONFIG.cell_view[target1.id][1]
            else
                view1 = GAME_CONFIG.cell_view[target1.id]
            end
        else
            view1 = GAME_CONFIG.element_view[target1.id]
        end
        gui.play_flipbook(
            gui.get_node("target_1"),
            view1 == "cell_web" and view1 .. "_ui" or view1
        )
        gui.set_text(
            gui.get_node("target_1_text"),
            tostring((tostring(math.min(#target1.uids, target1.count)) .. "/") .. tostring(target1.count))
        )
        gui.set_enabled(
            gui.get_node("target_1_fail_icon"),
            #target1.uids < target1.count
        )
        gui.set_position(
            target_1,
            vmath.vector3(-70, 0, 0)
        )
        gui.set_enabled(target_1, true)
        local target2 = state.targets[2]
        local view2 = ""
        if target2.type == TargetType.Cell then
            if __TS__ArrayIsArray(GAME_CONFIG.cell_view[target2.id]) then
                view2 = GAME_CONFIG.cell_view[target2.id][1]
            else
                view2 = GAME_CONFIG.cell_view[target2.id]
            end
        else
            view2 = GAME_CONFIG.element_view[target2.id]
        end
        gui.play_flipbook(
            gui.get_node("target_2"),
            view2 == "cell_web" and view2 .. "_ui" or view2
        )
        gui.set_text(
            gui.get_node("target_2_text"),
            tostring((tostring(math.min(#target2.uids, target2.count)) .. "/") .. tostring(target2.count))
        )
        gui.set_enabled(
            gui.get_node("target_2_fail_icon"),
            #target2.uids < target2.count
        )
        gui.set_position(
            target_2,
            vmath.vector3(70, 0, 0)
        )
        gui.set_enabled(target_2, true)
    elseif #state.targets == 3 then
        local target1 = state.targets[1]
        local view1 = ""
        if target1.type == TargetType.Cell then
            if __TS__ArrayIsArray(GAME_CONFIG.cell_view[target1.id]) then
                view1 = GAME_CONFIG.cell_view[target1.id][1]
            else
                view1 = GAME_CONFIG.cell_view[target1.id]
            end
        else
            view1 = GAME_CONFIG.element_view[target1.id]
        end
        gui.play_flipbook(
            gui.get_node("target_1"),
            view1 == "cell_web" and view1 .. "_ui" or view1
        )
        gui.set_text(
            gui.get_node("target_1_text"),
            tostring((tostring(math.min(#target1.uids, target1.count)) .. "/") .. tostring(target1.count))
        )
        gui.set_enabled(
            gui.get_node("target_1_fail_icon"),
            #target1.uids < target1.count
        )
        gui.set_position(
            target_1,
            vmath.vector3(-125, 0, 0)
        )
        gui.set_enabled(target_1, true)
        local target2 = state.targets[2]
        local view2 = ""
        if target2.type == TargetType.Cell then
            if __TS__ArrayIsArray(GAME_CONFIG.cell_view[target2.id]) then
                view2 = GAME_CONFIG.cell_view[target2.id][1]
            else
                view2 = GAME_CONFIG.cell_view[target2.id]
            end
        else
            view2 = GAME_CONFIG.element_view[target2.id]
        end
        gui.play_flipbook(
            gui.get_node("target_2"),
            view2 == "cell_web" and view2 .. "_ui" or view2
        )
        gui.set_text(
            gui.get_node("target_2_text"),
            tostring((tostring(math.min(#target2.uids, target2.count)) .. "/") .. tostring(target2.count))
        )
        gui.set_enabled(
            gui.get_node("target_2_fail_icon"),
            #target2.uids < target2.count
        )
        gui.set_position(
            target_2,
            vmath.vector3(0, 0, 0)
        )
        gui.set_enabled(target_2, true)
        local target3 = state.targets[3]
        local view3 = ""
        if target3.type == TargetType.Cell then
            if __TS__ArrayIsArray(GAME_CONFIG.cell_view[target3.id]) then
                view3 = GAME_CONFIG.cell_view[target3.id][1]
            else
                view3 = GAME_CONFIG.cell_view[target3.id]
            end
        else
            view3 = GAME_CONFIG.element_view[target3.id]
        end
        gui.play_flipbook(
            gui.get_node("target_3"),
            view3 == "cell_web" and view3 .. "_ui" or view3
        )
        gui.set_text(
            gui.get_node("target_3_text"),
            tostring((tostring(math.min(#target3.uids, target3.count)) .. "/") .. tostring(target3.count))
        )
        gui.set_enabled(
            gui.get_node("target_3_fail_icon"),
            #target3.uids < target3.count
        )
        gui.set_position(
            target_3,
            vmath.vector3(125, 0, 0)
        )
        gui.set_enabled(target_3, true)
    end
    set_gameover_offer()
end
function set_gameover_offer()
    gui.set_enabled(
        gui.get_node("gameover_offer_close"),
        true
    )
    if not is_time_level() then
        if GAME_CONFIG.steps_by_ad < 2 then
            gui.set_enabled(
                gui.get_node("steps_by_ad/button"),
                true
            )
        end
        gui.set_enabled(
            gui.get_node("steps_by_coins/button"),
            true
        )
    else
        gui.set_enabled(
            gui.get_node("time_by_coins/button"),
            true
        )
    end
end
function disabled_gameover_offer()
    remove_lifes(1)
    gui.set_enabled(
        gui.get_node("gameover_offer_close"),
        false
    )
    gui.set_enabled(
        gui.get_node("steps_by_ad/button"),
        false
    )
    gui.set_enabled(
        gui.get_node("steps_by_coins/button"),
        false
    )
    gui.set_enabled(
        gui.get_node("time_by_coins/button"),
        false
    )
    gui.set_enabled(
        gui.get_node("gameover_close"),
        true
    )
    gui.set_enabled(
        gui.get_node("restart_button"),
        true
    )
    gui.set_enabled(
        gui.get_node("map_button"),
        true
    )
end
function disable_game_ui()
    gui.set_enabled(
        gui.get_node("buster_buttons"),
        false
    )
    gui.animate(
        gui.get_node("substrate"),
        "position",
        vmath.vector3(270, 1050, 0),
        gui.EASING_INCUBIC,
        0.5
    )
    gui.animate(
        gui.get_node("system_buttons"),
        "position",
        vmath.vector3(0, -200, 0),
        gui.EASING_INCUBIC,
        0.5
    )
    timer.delay(
        0.5,
        false,
        function()
            gui.set_enabled(
                gui.get_node("substrate"),
                false
            )
            gui.set_enabled(
                gui.get_node("system_buttons"),
                false
            )
        end
    )
end
function on_shuffle_start()
    local shuffle = gui.get_node("shuffle")
    local lock = gui.get_node("lock1")
    gui.set_enabled(lock, true)
    gui.animate(
        lock,
        gui.PROP_COLOR,
        vmath.vector4(0, 0, 0, GAME_CONFIG.fade_value),
        gui.EASING_INCUBIC,
        0.3,
        0,
        function()
            gui.set_enabled(shuffle, true)
        end
    )
end
function on_shuffle_action()
    timer.delay(
        0.7,
        false,
        function()
            local shuffle = gui.get_node("shuffle")
            local lock = gui.get_node("lock1")
            gui.set_enabled(shuffle, false)
            gui.animate(
                lock,
                gui.PROP_COLOR,
                vmath.vector4(),
                gui.EASING_INCUBIC,
                0.3,
                0,
                function()
                    gui.set_enabled(lock, false)
                end
            )
        end
    )
end
presets = {targets = {
    {
        node_name = "first_target",
        preset_depend_of_length = {
            [1] = {
                position = vmath.vector3(0, 0, 0),
                scale = vmath.vector3(0.5, 0.5, 1)
            },
            [2] = {
                position = vmath.vector3(-50, 0, 0),
                scale = vmath.vector3(0.5, 0.5, 1)
            },
            [3] = {
                position = vmath.vector3(-55, 20, 0),
                scale = vmath.vector3(0.4, 0.4, 1)
            }
        }
    },
    {
        node_name = "second_target",
        preset_depend_of_length = {
            [2] = {
                position = vmath.vector3(35, 0, 0),
                scale = vmath.vector3(0.5, 0.5, 1)
            },
            [3] = {
                position = vmath.vector3(55, 20, 0),
                scale = vmath.vector3(0.4, 0.4, 1)
            }
        }
    },
    {
        node_name = "third_target",
        preset_depend_of_length = {[3] = {
            position = vmath.vector3(0, -35, 0),
            scale = vmath.vector3(0.4, 0.4, 1)
        }}
    }
}}
function ____exports.init(self)
    Manager.init_script()
    self.druid = druid.new(self)
    self.level = GAME_CONFIG.levels[GameStorage.get("current_level") + 1]
    self.busters = self.level.busters
    self.block_input = false
    set_text(
        "text",
        Lang.get_text("play")
    )
    self.druid:new_button(
        "btn",
        function()
            local window = gui.get_node("window")
            gui.set_enabled(window, false)
            EventBus.send("HIDED_ANIMAL_TUTORIAL_TIP")
        end
    )
    set_events(self)
end
function ____exports.on_input(self, action_id, action)
    if self.block_input then
        return false
    end
    return self.druid:on_input(action_id, action)
end
function ____exports.update(self, dt)
    self.druid:update(dt)
end
function ____exports.on_message(self, message_id, message, sender)
    Manager.on_message(self, message_id, message, sender)
    self.druid:on_message(message_id, message, sender)
end
function ____exports.final(self)
    self.druid:final()
    Manager.final_script()
end
init = ____exports.init
on_input = ____exports.on_input
update = ____exports.update
on_message = ____exports.on_message
final = ____exports.final

